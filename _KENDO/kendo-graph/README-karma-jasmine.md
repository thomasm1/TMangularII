Testing Angular
Introduction
In this module, we're going to learn how to test our code with Angular. In Angular, we do our testing with Karma. We can test our code without Karma, but Karma is such a great utility, that we're definitely going to want to leverage it when we're testing our code. If you're interested in learning more about testing with tools other than Karma, my course on testing JavaScript covers the main testing libraries that are used when testing JavaScript, which are Jasmine, QUnit, and Mocha. Angular by default uses Jasmine, although, you can use any testing library. But, Jasmine happens to be better supported, so we're going to use Jasmine in this module. It's important to node that in this module, I'm going to assume that you already know how to use Jasmine. If you don't, again I'll refer you to my course on testing clientside JavaScript. I have an entire module on Jasmine. I highly recommend you go watch it. In addition to that, we'll be covering mocking. In that same course, I have an entire module on the sign on mocking library. That would be another good module to watch if you have no idea what sign on is and how to use it. After we talk about Karma, we're going to talk about how to unit test. We're going to start by looking at how to unit test controllers. Then, we'll look at how to unit test services, then filters. Then finally, we'll wrap up our unit testing by looking at how to unit test directives. The last thing we're going to look at is how to do end to end testing with Angular. End to end tests is a very unique and very powerful feature of Angular that allows you to write tests that exercise your application in a production environment. You can essentially automate the browser and go through scenarios that utilize your actual application, just like a user would, and make sure the application works the right way. These kinds of tests can be very valuable, but they can also be very brittle because they might break easily when you change your HTML. So, be careful when writing your end to end tests, that you don't make them too brittle by tying them very closely to your HTML. Because we'll be using some tools that are external to Angular, now is a good time to check the GitHub Repo for this course, and make sure that the course is up to date.

Installing Karma
In this module, we're going to be using Karma as our test runner. Karma is a testing automation tool built by the Angular team at Google. It was formerly known as Testacular, but has been renamed as Karma. So when you're looking for information for or about Karma, you should keep in mind that it used to be called Testacular. Karma is completely independent of Angular. And you can test Angular without Karma. And you can use Karma to test other types of JavaScript, and not just Angular. Karma is also extremely fast, especially when running against Chrome. We're going to briefly see how to install Karma. If you have any trouble following along with this part, my course on testing clientside JavaScript takes a deeper look at Karma. You can go through an in depth tutorial on how to install Karma in this course, in the module on testing utilities in the third clip, which is all about Karma. Let's just quickly look at installing Karma, and a couple of other necessary pieces. I've opened up the command line, and we're going to install Karma using NPM. There are three modules I need to install. Karma itself, Karma Chrome Launcher, which is a module that lets Karma launch and run its tests inside of Chrome, and finally, Karma Jasmine. Now depending on your version of NPM, you may also need to install Jasmine Core. It's installed automatically with Karma Jasmine, but newer versions of NPM potentially may not install automatically. This module allows Karma to run tests using the Jasmine unit testing framework. I've installed those modules locally, but there's another module that I need to have installed globally in order to run Karma from the command line, and that is the Karma command line interface. So again, I'll install using NPM, but I'm going to install the module Karma-cli, which is the Karma command line interface, and I'm going to install it globally using the dash G flag. Since I've already installed the Karma-cli on my machine, I'm not going to execute this command at this time. But if you don't have it installed, you'll need to install this module in order to be able to execute Karma from the command line. Installing Karma is only the first step. The next thing you need to do is give Karma a configuration file. The project that you downloaded at the beginning of this course includes a configuration file that's set up for our project. But we can also generate a Karma configuration file by hand using the Karma init command. This is going to walk me through a series of questions that will create a Karma configuration file for me. The first question is which framework I want to use. I'm going to accept the default answer of Jasmine. Next, it asks me if I want to use required JS. Now if you're following along, the questions that you encounter may or may not be the questions that you'll see here. As new versions of Karma are released, they sometimes change the questions that are asked. Don't worry, usually the default answers are what you want. And reading the questions carefully will usually clue you in as to how you should answer them. So I set the default for this question. This is an important question about which browsers I want to capture. I definitely want Chrome, but I can certainly add more by pressing Tab, and selecting other browsers. For example, if I wanted Fire Fox, I would then hit Enter at this point. For now, let's just stick with Chrome. The next question is which files do I want to include. I'm just going to give it a simple answer of all of my JS files, which would be **/*.JS and that will be the only pattern that I'll put in. Then, I'm asked if I want to exclude any files. I'm going to skip this. And it asks me if I want to watch the files and rerun whenever they change. I'll select yes. And now, the process is complete and Karma has generated a configuration file for me. Now instead of examining the configuration file that we just created, instead, let's examine the configuration file that's in the demo project that you downloaded in the beginning of this course. Here's the configuration file that's included with the sample project. Let's go through each of these pieces and go through them one by one. We start off with a base path. This is the path that relative to the configuration file, is the root for all the other paths inside of this file. Next, we have a collection of files. This is an array of strings. It's very important here to put you files into the proper order. For example, you'll see the Angulars listed first. That is because it is a dependency for just about every other file listed in my files list. After Angular, I include all the Angular modules, which in our case is going to be Angular Route and Angular Resource. Then we've got the Angular Mocks file. If you are updated to the very, very latest version of Angular, you'll also need to update this file as well. Then we've got the sign on testing library. You can see that we show 1.10 here in the video, but this has actually been updated to the latest version on the demo that you'll download from GitHub. After that, I include all of the JavaScript source files that we created earlier in the course. And then finally, is all the files that include our unit tests. The next setting, auto watch, tells Karma that we want to watch the files for changes and rerun the tests whenever they change. After that is our testing framework. In this case, we're using a Jasmine testing framework. Next, is a list of browsers that we want Karma to run our tests in. Here, I've just listed Chrome, but I can easily add more browsers, such as Fire Fox, or Chrome Canary, or IE. After that is a list of plug ins for Karma to load, and you can see I've listed the Karma Chrome Launcher and Karma Jasmine, which we installed earlier. And then finally, some output settings. And there's the Karma configuration file that we'll be using for this course. The final piece we're going to show is how to run Karma from the command line. Running Karma from the command line is very simple. You simply run Karma, start, and then the path to the config file. In this case, the path is at test Karma.conf.JS. And then I'll hit enter, and Karma will launch the Chrome browser and run my tests. Now, I've actually loaded up some sample tests. If you're following along and execute this command at this point, you'll actually execute zero tests, because we haven't created any unit tests yet. And now, I want to terminate Karma, so I'll hit Control+C, and Karma will exit. So, there's how to install and run Karma in order to run your unit tests.

Karma with Webstorm
In this section, we're going to show how to use Karma inside of WebStorm. Now if you're not using WebStorm, you can go ahead and skip this part, but you may want to follow along just to see what you're missing out on. The integration between Karma and WebStorm is really slick, and can be really convenient when building an application. The first thing I need to do is tell WebStorm how to run my Karma. In order to do that, I'm going to go up here to this button, click it, and select Edit Configurations. These are run configurations that allow WebStorm to run external programs. After I select that, I'm going to click the green plus button. And now, I get to look at a list of possible types of run configurations I want to create. Of course, I'm going to go down here and select Karma. At this point, I see a few things. First, is the name of my configuration. Unnamed doesn't work very well, so I'm going to rename that. This is also asking me where my node interpreter is at, and it's filled it in with what it thinks is the correct answer. In this case, this is correct. This is where my node interpreter lives. On your box, it might be different. The next piece of information that needs to be filled in, is where Karma is at. If you followed along and installed Karma the way that I did, then this is what should show up, and that's going to be the correct path. If you installed Karma globally or in some other location, you may need to help WebStorm by pointing it at the right path. The last piece of information that we have to fill in, is the configuration file. This is going to be our karma.conf.js file. This is very simple and just click Browse, select the file itself, and then hit OK. And now, my configuration is set up correctly, so I can just hit OK, and I'm ready to run. Now that we've got it configured, let's go ahead and run it and see what happens. So you can see after a brief pause, Karma has launched and ran all of my tests. We're getting a few pieces of information that's very interesting. First off, is this little message here that says if we want to rerun our tests, we can just hit Alt+Shift+R. I'm going to click Got It on that. Up here at the top of the window that pops up, you can see that it says, done nine of nine. That's indicated that nine of nine tests have run. The green bar across the right hand side is a progress bar that will slowly fill in as Karma runs my tests. In the main section here, on the right hand side, we've got the log output, and on the left is a tree that shows me which tests have run, and whether they've passed or failed. Let's go ahead and look at this. First, you can see that the top node is the test results. Then, it shows my Karma configuration file. Underneath that, it's going to show a node for each browser. This way, if you're running your tests in multiple browsers, and some browsers are failing and some are not, you can see that very easily. Let's pop open Chrome, and we can see that there are several different test suites. These are the test suites that we're going to be building inside of this section of the course. I've already installed them, so that you can see what it looks like when you're running multiple tests. Inside of a test suite, if you open it up, it will show you each specific test an whether or not that test passed or failed. In addition to that, we have a few tool buttons across the top that will give us some nice features. For example, we can hide our past tests, and look at only the failing tests. We can sort our tests alphabetically. We can also expand all of our tests, or collapse all of our tests. And then using these two buttons, we can quickly navigate between each failing test. There's another tab here I want to show you and that is the Karma server itself. This is the output of the Karma server, and this allows you to stop the entire Karma server using this button, so that you can restart it in case your configuration has changed. In general, WebStorm will detect when your configuration file has changed and relaunch the Karma server for you, so you'll rarely have to do this yourself. Now, let's go back to our Test Run tab, and I want to show you a couple more things. One interesting feature that WebStorm has is the ability to look at statistical information about your test run. You can right-click on your test and select Show Statistics. At this point, another window pops up that shows you statistics about the tests. You can see here that it's taken 56 milliseconds, and nine tests have passed. I can select a subsection in my tests and do the same thing, and it will show me the information for just that subsection of tests. Should I want to turn that Statistics Panel off, there's a tool button for that. But, I need to expand this to show all of my tool buttons. Right here is a Settings tool button. If I click that, I get a little drop down. I can turn off Show Statistics. And there's also a couple of other interesting features there. If I want, I can select the first failed test when the run is finished. I can tell it to scroll to my Stack Trace. And I can also set the Auto Test Delay. By default, WebStorm turns off auto running of tests, so whenever you change your code, Karma will instantly rerun. Instead, it waits for to hit the keystroke that will rerun the tests. If you actually want Karma to automatically rerun when your code changes, you can come over here and select this tool button right here, Toggle Auto Test, and that will turn auto testing on. Then inside of here, you can configure the delay that you want WebStorm to wait between running your tests. Whether you prefer to use the keystroke or have WebStorm auto rerun your tests for you, is up to you. And that will conclude our look at using Karma inside of WebStorm.

Testing Controllers in Angular
In this first section, we're going to learn how to test controllers. Since controllers are the heart of any Angular application, it's only natural that we learn to test them first. We're going to start by learning to test our event list controller. This is a great starting point because it's an extremely simple controller. All it does is one thing on line five, which is call eventdata.getAllEvents, and then assign it to the events properties on the scope. So, let's create a test that verifies that whatever comes out of the getAllEvents call, gets put onto the events property on the scope. I've got a blank test file here. I've named it Event List Controller Spec, and I put it inside of the unit folder inside of my test folder. This will contain the tests for our event list controller. I'm going to start out by calling the describe function. This is the way, in Jasmine, we group our tests. This function takes in two parameters. The first is a title or name. And I'm going to name it event list controller. And the second is a call back function. Inside of this describe function, is where I'm going to actually write my tests. Any tests we write will go inside of an it function, and that takes two parameters, the name of the test, which is a string so that we can put in spaces. And I'm going to name this test should set the scope events to the result of event data .getAllEvents. Now, I know that's a really long name, but it's nice to have descriptive names for your tests. The second parameter to the it function is just like the describe function. It's a call back. Inside of here, is where we'll do our actual testing. Now ultimately, what we need is a handle to the scope that the controller creates. Going back to look at the event list controller, we can see that it receives in this scope as a parameter, and it sets the events property on that scope. So in our test, ultimately we'll need to have the scope and check its events property. When we check something in a Jasmine test to make sure that it's the way that we want, we use a function called expect. And we're going to expect that our scope.events is equal to something. We'll use the to be function and we'll check to make sure it's equal to a specific mock events object that we'll create. So, I'll call this mock events. Now, I've got to create this mock events object, so I'll start by creating a variable for it, and set that equal to an empty object. And the next step will be to get the events list controller to actually initialize that scope for us. Now, this is going to take a few steps. First off, the event list controller actually lives inside of the Events App module. So, we're going to have to load the module up. In order to do that, we're going to go up inside of our describe, and we're going to call the before each function. The before each function is a function that will run before each test. This function is where we want to initialize our module, and we do that by calling the module function. The module function is not specific to Jasmine, it's specific to Angular testing. Because in our tests, we loaded up the Angular mocks library using Karma, the module function is available for us to call. This takes in one parameter, which is the name of our module. And since our module is Events App, we just simply feed in that name, and now the module has been loaded up, and now I have access to the event list controller. So now, we need to get a handle the event list controller. But in order to do that, we'll need a special service from Angular called the Controller Constructor. In order to get a handle to that service, we're going to use another before each function, and this one we're going to call the inject function. The inject function is another special function inside of Angular. This function takes in a call back. And this call back is an injectible call back. So any parameters that we pass, Angular's going to try to look them up in its registry and find matching services for that. So, we want the Controller Constructor, and that's available as $controller, and we'll assign that a variable called controller constructor. And since we need access outside of this before each function, we'll create it as a variable up here. Once we have that service, we can now construct our controller, and doing so will initialize the scope. So, we go down into our test, and we're going to create a variable called controller, and assign it equal to the value of that special service. And that takes in two parameters, the name of the controller itself, which is event list controller. And the second parameter is a list of all the parameters that go into the event list controller. So if you go back to the event list controller, we can see that there's three parameters, $scope, $location, and event data. Of course, right off the bat we should notice that $location is completely superfluous, and isn't used by the controller. So, let's remove that. So now, we need to just pass in the scope and the event data service. So first, let's tackle the scope. We can't just pass in an empty object here because scopes are special things. Instead, what we need is a blank scope, that our controller can fill out. So again, we're going to need a special service to create a blank scope. We'll go up here into our before each, and we'll ask for the root scope service. Once we have that service, we can create a new scope by calling rootScope.$new. And let's assign that to a scope variable, and we'll declare that up here. And we indicate the parameters to this controller constructor by putting them inside of an object with keys indicating the name of the parameter. So again, back to our controller. We can see the first parameter is $scope. So, our first key in our object will be $scope and the value of that will be the scope object that we created on line 10. The second thing we need to pass in is event data. Now again, we can't just pass in a blank object because inside of the controller, we call eventData.getAllEvents there on line five. So what we need is an object that has a getAllEvents method. What we don't want to do is create a real event data service, because now we'd be testing two different things. And if there is a bug in the event data service, it would show up in our tests for this controller. We want to isolate our tests, because they're unit tests, and only test one thing at a time. So instead of trying to use the real event data service, instead, let's create a mock event data service. So, let's go up to the top and we'll create a new variable called mockEventData, and inside of our before each, we'll set that variable equal to a call to sign on. This is where that sign on library comes in handy. If we call signon.stub and pass in a template object, and again we want to match the signature of the event data service, at least as far as what the event list controller calls. And all it knows, is it has a getAllEvents method. So, let's create a blank events object with a getAllEvents method, and we can just create a blank function there. And, I need to spell that right, I getAllEvents. And now what sign on, we'll do, is take this template, and create an object that looks just like this, but it gives us control over how that object functions. And, we're going to use that functionality in our test. So now, we can go back down onto line 18, and for event data, we're going to pass in our mock event data, and remember, our expectation is that scope.events is the mock events object that we created on line 15. So, in order for that to work, what we need is for our mock event data service to return the mock events object when getAllEvents is called. So now what we need to do is tell our mock event data service to return the mock events object when getAllEvents is called. And we do that using the functionality of sign on, where we can tell it mockEventData.getAllEvents, which is a function, but because this is sign on, this function has a returns function itself. And this is us telling sign on, hey, when somebody calls getAllEvents, I want you to return this value. In our case, thats mock events. So now, whenever anybody calls getAllEvents on the mock events data object, they're going to receive back the mock events object. And that matches up exactly with what we want, because inside of our control, we call getAllEvents and assign it to the events property, and we're going to check and make sure that what gets assigned to the events property is the mock events object. This will fix that functionality so that if anybody comes in and changes the event list controller so that the return value from getAllEvents is no longer what goes on to the events property of the scope, this test will break and warn them that they've broken functionality. And one thing that you may notice is we don't actually use this controller variable that we're creating here on line 18. So even thought the controller gets constructed, really the only thing we care about is what it does to the scope. We don't actually need to do anything with the controller inside of our test after it's done its job of initializing the scope. So, let's remove this and then, let's run our test. So, go down and click the Run button. And you can see that we've now got a message done one of one, we have all of our tests passing, and our test for our event list controller is now working.

Testing Controllers in Angular Part 2
Now, let's write another controller test. But this time instead of testing event list controller, let's test our edit profile controller. So, let's open up the edit profile controller, and we can see that it's doing a couple of things. It's creating a blank object and assigning it to the user property, and it's also setting up a get gravitar URL function. So, let's test that get gravitar URL function. I'm going to open up a test file for this controller that I've created. And I've already created the empty wrapper for it. And we'll just do a little bit of copy and paste magic and go back into our other test. And let's grab the before each. Well, let's grab from this var all the way down to here. And we'll copy it into our test. But, we don't need a mock event data for this test. Instead, we're going to need a mock gravitar URL builder, because that service comes in alongside the scope here on line four, and so we'll need that mock service, and we will change this mock event data here to that. And the signature of that isn't get all events. Instead, we call build gravitar URL, so we will add a build gravitar url function, and then we can create our actual test. In this case, our test will be that it should build our gravitar with a given email address. If we look back at our call to our function, the function itself takes in an email address, and then passes that same email address into the build gravitar URL. So, that's the functionality that we will test. We'll make sure that whatever comes in on the parameter on line seven, is what goes into the build gravitar URL call on line eight. So again, we'll have to construct our controller, and we do that by passing in the name of the controller, which is edit profile controller. And the second parameter, of course, is the parameters that go into the controller, which we have two, the scope, and the gravitar URL builder, which is going to be our mock gravatar URL builder. Now, we need an email address to pass in, so create an email variable. And now that that's created, we're going to call the get gravitar URL function that's on the scope, which is the function that gets built by our controller there on line seven. So again, remember, that function does not exist on the controller, it exists on the scope. So, we call scope.getGravatarUrl, and we're going to pass in that email address, and then, we can set up an expectation that the mock gravatar URL builder, we want to check that the function build gravitar URL was called with, and again, this is a little bit of sign on magic. Sign on tracks any function that was called on a sign on object, every invocation of what parameters it was called with. So, we're going to check that it was called with the email address that we created, and we're going to expect that this is truthy. And again, this will verify that whatever email address gets passed into the call to get gravitar URL, is the same address that gets passed into build gravitar URL. And if we run our test, we now have two of two passing. And there's the basics of testing controllers in Angular. Again, a few key pieces that are important to know and that is, how to create a controller how to pass a blank scope object, so that it can fill out that scope object, and how to create and pass in any mock services that that controller needs to do its job so that you can test the functionality for the controller. Since the controller's job is usually to set up the scope, when testing a controller, you usually end up testing the scope that it creates. So, just be aware of that, that what you'll usually end up doing is just testing the scope that the controller creates.

Testing Services in Angular
In this section, we're going to learn how to test services. Specifically, we're going to learn how to test very simple services. So, we're going to start by looking at testing the calendar helper. The reason that we're going to start with this one is, as you can see, it has no dependencies. So, we don't need to worry about mocking anything. Instead, it just returns back an object with a couple of functions, and each of those functions takes in some parameters, and returns a value. That's going to make this very easy to test. And really, we're going to just use this as a way to get warmed up and see the very basics of testing services, so that we can be comfortable when it comes time to test more complex services. Because of that, we're not going to test both of these functions extensively. Instead, I'd just like to test the get month name function, and I'm just going to write one simple test for that function. So you can see, I've already got the spec created for it. So, I'm just going to write one simple test. I'll write a test to verify when we pass in the zero, January is returned. Now if you'll remember when we were testing our controllers, in the before each function, we called the inject function. That gave us the controller constructor and the root scope. Inject is a way to ask Angular to give you services. So when we're testing services, we just the inject function to get the service so that we can test it. So, I'm going to call inject here, and then inside that, pass in a function. And the parameter I'm going to give that function is the service that I want to test, so in this case, it's calendar helper. Now, this looks a little different than the test that we wrote for the controller, and probably any other Jasmine tests you may have written, because instead of just passing a function into it, we passed the inject. But, the net result is the same. The tests still work just fine, but this allows us to get a calendar helper that's constructed by Angular. So now that I've got that calendar helper, I can write my expectation. Now, one more thing I need to do before I can run this that we learned about when we were testing controllers is I need to invoke the module that has this service inside of it. And the way that I do that is in a for each function, where I call the module function, and give it the name of my module. And now you can see that as soon as I saved it, it ran the tests, and executed my new test, and that one passed as well.

Testing Services with Dependencies
Now that we've seen how to test a simple service, let's test a slightly more complex service. Let's test a service that has a dependency. We don't really have a great service in our project already for this purpose, so we're going to add a little bit of code just for the purpose of testing. We're going to add the userData service, which you see here. This userData service works almost exactly like the eventData service, except instead of using the built-in Angular resource directly, it has a dependency on the userResource service, which wraps Angular's resource service. You can get both of these files, the userData service and the userResource service, from the GitHub repo for this course. The URL is shown here. Just download these two files and add them to your project. Looking at getUser, it does essentially one thing. It calls userResource.get and returns that value. So let's write two tests, one that tests each of those aspects. Now since I'll be writing tests for two different functions, I'm going to make this a little bit easier one that tests each of those aspects. Now, since I'm going to be writing tests for two different Now remember, I have to call inject in order to get an instance of my userData function, and then I'll take the important action on the userData service, which is to call getUser, and let's pass in bob as the username. Now since userData internally calls userResource and I want to test what parameters it calls userResource Now that I got a describe for get user, mockUserResource, and I'm going to check that the first argument of the first call is an object that has a username of bob. I use toEqual here instead of toBe so that it doesn't check identity, but instead just checks that the objects are equivalent and have the same properties with the same values. Now the next problem I need to solve is that I don't actually have a mockUserResource object, so I'm going to create that in a beforeEach. And since the variable has to be accessible both in the beforeEach and in the it, I'm going to define that variable outside of them both. Now the userResource object has one function that I care about, and that's get. Okay, now I've created the mockUserResource object, but the userData object, when it gets constructed by Angular, is still going to use the real userResource service that I created in my application and not this mock one, so I need to tell Angular that when the userData service asks for a userResource service to use my mock instead of the actual service, and the way that I do that is by getting ahold of Angular's provide object. And in order to get ahold of the provide object, I call the module function and pass in a function. The provide object has a value function, and that value function takes in two parameters, the name of the service and the value that should be provided whenever anybody asks for that service. By calling this line of code right here, I've told Angular that whenever anybody asks for a userResource object to use my mockUserResource instead. And now that I've got that set up, I've got one last piece to do, and that is to invoke the module. Now that I've got those in place, I can save and run the file. And now that that's run, you can see that the new test is passing also. Okay, let's write another test for getUser. Looking at the getUser function, we can see that it returns whatever userResource.get returns, so let's just verify that with a test. So I'm calling getUser and capturing the output. I want to expect that that output is some known value, so now I just need to tell my mockUserResource to return the string angular rocks. Alright, let's save that and see what we get. Okay, that test is passing too. Now that we've got those two tests going, let's write one more test, and we'll write this one for the save function. So I'm going to go after my describe and write a new describe, and I'm going to go look at the save function, and I can see that it calls userResource.save with whatever value you pass in, so let's just write a test for that. Okay, so I've called userData.save, and I've created an expectation that the mockUserResource's save function was called with that same value. Let's save, and that will run our tests and see what we get. Okay, we're getting a failure, so let's look at it and see what the problem is. Alright, our error is that the object has no method save. Well, the object it's trying to call save on is my userResource object, which in my test is the mockUserResource object. So if I go up in my test, we can see that I've only defined a get function for my mockUserResource object and not a save function. Alright, now that I've got a save function defined, let's try running this test again. Okay, now our test is passing. So there's a great example of how to test a service that has a dependency and be able to provide a mock dependency. Whenever we're testing services, we always want to use mock dependencies for all the dependencies on our service so that we're testing our service in isolation. That way, whenever any tests for any of our services break, we know that what broke was the service and not one of its dependencies.

Testing AJAX Services in Angular
The other kind of service we'd like to learn how to test, the services that talk to the server using http or resource. So, we have a great service as an example of that, which is our event data service. We'd like to test that. Now, of course using sign on, we could just pass in a mock $resource service into this event data service, and then, just test the code that we write. It gets called the way that it's written. But, that's a little bit ineffective, because we want to know that we configured our resource correctly. And the only way to really know if we've configured it correctly is to know that is makes the calls the way that we expect them to be made. So, that it calls to the correct URLs using the correct verbs like a get or a post. So, other than using a mock resource, it'd be nice to use a real resource, but instead of letting it actual make real http calls, we'd like to intercept those issue http calls and just find out what they were. And there's a special service inside of Angular's mocks library that we can use to do exactly that. So, let's go to our event data spec, which I've created, of course, with our empty describe function. And, of course, we'll start off with a before each to invoke the module. And our first test will be to check that when we call get event on our event data service, that we call to the right URL. So, we'll say it should issue get request to /data/event. Must use and ID of 11 when get event is called and the ID is 11. And the second parameter for our it function is not going to be just a simple call back function, but instead, we're going to pass in the inject function. Because, of course, we need the live event data service, but we also need another service from Angular, and that is the http backend service. This is the service that intercepts any actual XML http request calls, and will tell us what they are. And so inside of this call back function, we're going to do a couple of things. First, we know that we're going to be making a call, hopefully, to /data/event/11. So, we're going to take that http backend service, and we're going to say that you are going to expect a get of /data/event/11. And then, we can call eventData.getEvent and we'll pass that on the ID of 11. And again, going back to our event data service, when get event is called, it takes in an ID, and then internally, then calls resource.get, with an object whose ID is set to the ID that was passed in. So, when that happens again, it should call /data/event/11 based on how we configured the resource inside of our event data service. The other thing we have to do now that we've actually caused the resource to do something and make some kind of an http call, is we need to flush the http backend. And we call .flush, and this basically just makes that service go through any calls and report out what happened and respond to them if a response is necessary. Then finally, we can check and make sure that we only made the calls that we expected. There on line nine, we set up an expectation for our get, so let's check that we only have the calls that we expected, if we can call httpBackend.verify no outstanding expectation. And we can also call httpBackend.verify no outstanding request. And that's most of the way. But, the other thing that we need to do is tell our http backend what to do when this actual call to /data/event/11 happens, what it should do, and what it should return. In this case, we don't really care what it returns, we just need it to return something. So, we call httpBackend.when. And this allows us to say, hey, when a specific call comes through that matches this verb, so we pass in the verb, which is going to be get, and this URL. Then, I want you to respond by returning a specific object or a return value. In this case, we're going to return an empty object. And because we're not doing anything with the return value, going back to our event service, all it does is on line five is return whatever comes back. And so, we don't really care what gets returned in this test. We just want to make sure that only that specific call gets made. So now, if we go and run our test, we can see that all of our tests are passing. And so, if we were to go down here and change this ID from 11 to 12, then the URL would no longer be /data/event/11. It'd be 12 in our test would fail. And we can verify that by running and we get, indeed, one failure. So, we'll change that back to 11 and run again. And our tests are passing.

Testing AJAX Services in Angular Part 2
So now that we've got our first tests running, let's write a couple more. Let's check that we returned the correct data when get event is called. And, of course, we pass in our inject, bringing in the same event data, and the http backend. Now, this test is going to do almost the same thing as the previous test, but in this case, we won't set up expectations. We'll just check that whatever we respond with is what actually gets returned out. So again, we'll use http backend and we'll say, when you receive a get request to /data/event/11, that you respond with an object. In this case, we can form the object any way we want. So, we'll give it a name property and call it my event. And then, we'll call that get event, but capture the output. And then, of course, we have to flush the http backend. And then, we can set up an expectation that the event.name is the string my event, which is what we set in the object to be returned. So if we run our test, you can see we've got five passing tests. Now, these two tests essentially do the same thing, but they do them in different ways. The first one, we set up these expectations, this expect get right on the http backend, and the test fails if that get doesn't get called. Whereas the second test, we just check that the value that comes out of the call matches. But, we've also set it up so that that value only comes out when a specific URL gets called. So, we've said that when we get a get request to data event 11, then respond with this object. Then, we call the method and check that that's the actual object that we got. Now, one interesting thing here is that even if we were to change and make this the wrong URL, if we run the test, we'll get an error that says, hey, unexpected request to get data event 12. So, it already clues us in on what the problem is. So, it's pretty much just like the previous test, only it's set up a little bit differently and it requires a little bit less code. So, I kind of prefer the second method of doing tests with the http backend. But, either method is completely valid. So, now we've effectively tested the get event method on our event data service. Let's also test our save method. And, we know that when we call eventData.save, if we look at the code, it actually hard codes the ID of the new event to 999, which of course, is just a little bit of hard coded value here because we didn't want to create an ID algorithm. So, we'll just test that that functionality works. In a real program, you'd probably generated IDs and then you'd rewrite this test just a little bit to make sure that the new ID was set correctly to a unique value. But in our case, we'll just check that it's set to the value that we expected. And again, we pass in inject. And we'll say, http backend when, this time, a saved call causes a post to happen. So, we'll check for a post with data/event/999. And we'll respond with a blank object, then we'll create a new event to pass in. This will be an object that has a name of my event. And then, we'll call the save method. Then, we'll flush the backend. And then, we'll expect that event.id is now 999. And if we run our test, we can see that that test is passing too. If I were to change this to 998, of course, I get a failing test because it's going to set the value to 999 instead. So now, we've got tests for get event and for save. We got one more method on our event data, that's to get all events. Let's write a test for that. And we'll just check that it makes the right get request. Passing in our inject function to grab the event data service and http backend service. And in this case, we'll set up our http backend to say that when we get a get request for data/event, and 'cause that's the URL that we get a request to when we call a get all events. Again, get all events, it just calls resource.query, so that uses the URL that we initialized the resource without any ID, so that would be just data/event, and then we respond. In this case, we're going to respond with an array that has one object in it. It has a name of my event. And then, we'll capture the result of that and, of course, flush the back end. And then, we'll set up an expectation that our first event, which would be the zeroth element in the events array, that it's name property is equal to my event. And we'll run our tests. And we have seven passing tests now. So, there's the basics of using http backend in order to intercept http calls and check that only the calls that we expect are made. And one of the features of http backend, of course, is that it will respond with whatever you set it up to respond to, based on the get request or the post request and the URL, whatever the verb in the URL is. But, another nice feature of it, is if it ever receives any unexpected http requests, then it will let you know, hey, I received an unexpected request. And that way, you're not getting any unexpected http requests inside of your services that use http or resource.

Testing Filters in Angular
In this section, we're going to learn how to test filters. Filters are fairly easy and straightforward to test. We only have one filter in our application, the durations filter, so we're going to write a test for that. The durations filter takes in one of four values. It returns out a string based on that value. Rather than writing all four tests, we're only going to write one test today, and I'll leave it as an exercise for you to write the other tests. Now, just like always, we know we need to invoke our module, so let's just start out with that. Now, I'm going to write a test that verifies whenever I pass in a one to the durations filter, it returns the string half hour. And as with services, I need to call the inject function in order to get my filter. But unlike services with filters, the paramater that I pass in needs to have the suffix filter. Going back to the filters object, you can see that the name of the filter is durations, but when I want to get a hold of it, I give the parameter durations filter. Now, my expectation will be very straightforward. The filter is just a function and I pass in the value and I verify that the output is what I expect. Now, let's run that test and see what we get. All right, you can see that the test has passed. But, if I come in here and change the expected string, the test is going to fail. So as you can see, testing filters is really straightforward. I still recommend that you play around with this and write other tests around the durations filter, or your own filter if you have one to test.

Testing Directives - Overview
In this section, we're going to look at testing directives. Testing directives can be rather complex. So in order to try as much as possible to clarify how it works, we're going to look at a diagram of the pieces involved and how they interact in a directive test. The first piece is the directive we have created. We won't explicitly tell our test to include this piece. Angular will get it for us and include it. Next, is the template for our directive. If this is an external template, then we will have to make sure that it is loaded for the test. If it's embedded in the directive, then we won't have to worry about it. Next, we create and set up a test scope for the test. We can give it whatever values make sense for the test. Then, we have a string that is some HTML that references the directive that we're trying to test. For example, if our directive is named my directive, then this is a node that's named my directive. Now, if we are using an external template in our directive, then we'll also need to tell Karma to run that directive through the HTML to JS preprocessor, which will take the HTML and create a snippet of JavaScript that will create the corresponding nodes in the DOM. Now that we have all these four pieces, we're going to run them through Angular's directive compiler. The essence of this piece is that it will look at the test HTML node represented by the green box, see that it has a directive in it, and go grab that directive. If that directive reference is an external template, then Angular will gather that piece from the HTML to JS preprocessor. Then, we will explicitly tell it to compile with our test scope, and Angular will take all of those pieces, and produce a set of valid HTML nodes that are attached to the DOM, but do have events wired up if our events specify them. Say for example, an NG click directive will produce an event list there under click events. Now that we have these DOM nodes, we can test them to see if they were created in the manner that we were expecting. As a result of this method, utliimately we're just testing a part of the DOM, and as such, these tests can evolve using a lot of jQuery to find a particular node. And then, either looking at that node, or triggering an event to see if that event was correctly wired up to some method on our scope, or that the directive takes some specific action when that event occurs. Like the other sections in this module, the most effective way to learn about testing a directive is to dig right into the code. So, let's turn to our project and write a directive test.

Setting up Karma for testing Directives
In this section, we're going to set up Karma to test our directives. Testing directives is a bit different than testing the other pieces of Angular, because of external templates. Normally, when Angular encounters a directive that specifies an external template with the template URL property, Angular will then make a get request for the template that that directive uses. When running in Karma, we don't want that get request to fire. Instead, we want to have our templates already loaded to allow Karma to supply those templates for us. So in order to do this, we have to do a little Karma wizardry. So, the first thing we'll do is install another NPM module. So using NPM, we need to install the HTML to JS preprocessor for Karma. This is the name of the node module, Karma NG HTML to JS preprocessor. I'm going to go ahead and install that. And once that's done, I'll go back into my project and make some changes to my Karma configuration file. Here in my Karma configuration file, I've got to change three things. First, I need to add my partial HTML files to the list of files that Karma will load. So, I'll go down to my files list, and add a new entry. Here, I've told Karma to load all of the HTML files inside of the directives subdirectory inside of my partials directory. Next, I've got to add the module that I just installed to the list of plug ins that Karma will load. And finally, I've got to add a preprocessor section to my configuration. It doesn't really matter where you add this. So, I'm just going to put it at the top. This preprocessor section is an object whose key is the pattern of files that you want to be preprocessed. So in this case, I want all of my HTML files to be preprocessed. And the value will be the name of the preprocessor. In this case, the name isn't exactly the same as the name of the module. It's just NG-HTML to JS. These three changes will get Karma to load all of my partial files for all of my directives. This will allow Angular to run directives under Karma, where it's not possible to request external templates for directives using the normal manner. Now, the most common way to get this wrong is through the paths. The path to your template URLs needs to match exactly the path to the templates inside the files section in your Karma config module. Let's look at an example of this. I'm going to open up the event thumbnail directive. And you can see right here, my template URL is partials directives event thumbnail. So, that path needs to match path in my Karma config file. If we go here, you can see here that all of our partials start with partials/directives/start.html. So therefore, the path is the same. It begins with the word partials. If I were to change the base path, so that instead of starting from app, it starts from the directory above app, then in order to get the partials, I'd have to put app in here. But now this path, from app partials directives doesn't match the path inside of the template URL, which is just partials no leading app. So, we've got to make sure that our base path matches up with how the templates are referenced. Now, there is one way to get around this. You can add a section to your Karma config file that gives directives just to the HTML to JS preprocessor. Let's add that section and show how it would work. Let's assume that our base path is a directory app, and even though that breaks the rest of our file paths, and we'll just ignore the fact that all the other paths are wrong and just worry about the partials path. So, this is our partials path in our Karma config file, yet the path inside of our directives is different. What we need to do is tell Karma to take off the leading app. So, we'll add a section to our configuration file called NT HTML to JS preprocessor. Inside of here, we're going to tell the preprocessor to strip the app prefix. We do that by adding a strip prefix key, and then setting app/ as the key. Now whenever the HTML to JS preprocessor processes an HTML file, it will strip off the app as part of the path and treat the path as if that wasn't there. And that will make our templates load correctly once again. This section can also preprint a prefix, if you need to add one. So in either case, whether you need to strip a prefix or add one, you can use this section to do it. Now, I'll clean up these changes, and now we're ready to start testing our directives.

Testing Directives in Angular
Now that we've got ourselves set up in order to test directives, let's go ahead and write our test for our directive. So, we'll use the event thumbnail directive as the directive that we're going to test. And if you look at this directive, you can see that the directive itself really has no functionality. All that it does, if you look at the HTML is you can see that it binds a bunch of data onto the DOM. So, let's just test that it binds the event name correctly. We can see that on line three here, that it binds the event name value in there. So, let's write a test to check that it does exactly that. Of course, the complex piece here is going to be all the set up. We'll start off by invoking our module. And the other thing that we need to do is make sure that our template is available. Again, the event thumbnail JS file has a template URL of /template/directives/eventthumbnail.html. I'm going to copy this exact string and go over to my event thumbnail spec. And remember that in our preprocessor, we're loading up all of the templates. And in order to make those available to our test, we actually have to invoke them, and using the same function that we invoke our module. So, that's a little bit confusing. We call the module function, but instead of passing in the name of the module, we pass in the name of the template. And, of course the string has to match exactly. Now that we have that, our template is available, so that when our directive makes a get request, instead of actually doing a get request for the template URL, it will internally use the preprocessor and just grab that HTML template out of the preprocessor's cache. So, or test is going to be that it should bind the data, so we'll do a very, very, very simple expectation here. We're going to expect that the HTML that gets created has the name of the event in it. So, let's assume that we've got a handle to some element which is the root of the HTML that's created by the directive, so we'll call that el. And remember in Angular, elements are wrapped by jQuery, so there's a text property, which spits out all of the HMTL as text. And we're going to check that this contains the name of our event. So, let's make the name of our event something a little unique. We'll call it Angular Expo. Now, of course, we're not done. We haven't given our directive any data to bind to, and we really haven't even gotten the directive itself to run. So, here's where all the complex magic happens. We're going to need another before each function, and we'll pass in inject, because we need Angular to give us a couple of services. The first one is the compile service and the second one is the root scope service. We need the root scope service because we're going to need a scope for our directive. We need the compile service because we actually need to compile the directive. Angular itself essentially just compiles directives, that's its main function. That's how Angular runs as it goes through your HTML, finds directives and then compiles them. And this compile service is the main service that does this. So, this is kind of the heart of Angular right here. So first, let's create our new scope. And then, let's created on that scope an event object. And the reason we need that is if we go back into our thumbnail JS, we can see that the event is some data that is passed into our directive. So, we will say scope.event and we'll set that equal to an object that has all of the data that needs to be available to bind onto our HTML. The key piece is our name, because that's going to be what we're searching for in our expectation in our test. So, the name will need to be that Angular Expo, and in order for this to work, we're going to need the other pieces of data, which are the date. In this case, it's just a string. So, pass in one, one, 2050. Add the time. Another string, 1030. We need a location, which is itself an object, and that has an address, which we will set to 1234 Fake Street, and a city, which we'll set to New York, and a province, which we'll set to New York. And let's double check our HTML and make sure that we've got all this address, city, and province. We can look up at the top. Ooh, it also needs an ID, so let's give our event an ID. And we'll set it to one. So, now we got our event created. Next, we need to create and compile the directive. So, this is where things get a little bit tricky. Again, we have this el property down in our test, that's going to be the DOM node that is the root of the directive. We're going to need to access that both in the test end here and in before each. So, let's create a variable up here and inside of our before each, we'll say, el equals angular.element, which lets us create an element. So, we're going to create the DOM element that is the directive itself and causes Angular to compile it. So, that's our event-thumbnail. And this is what we'd find somewhere else in our HTML that causes the event thumbnail to get run when Angular is running live. But, here we actually have to trigger it, so we're creating a brand new one. And of course, it needs that event property. So, we'll just say event is the name of the property we're passing in and we'll close it off. And so now, we got this element. And again, when Angular parses through our HTML, it finds directives and then compiles them. And in the compilation process, it turns them from whatever they are into whatever they should be after the directive itself runs. So, that's what the compiler service does. So, we'll call the compile service and we pass in that element, or DOM node. And what that compile function returns out is another function itself, which we have to invoke with a specific scope. This is kind of like a template function for the specific directive, but it can't do anything until it actually has a scope to operate against. So, since we've created a scope up on line nine and filled that scope out with the data it needs on line 10, we can just immediately invoke that function, and pass in the scope. Now, there's one final thing that we need to do in order for Angular to update the bindings. And that is, we actually have to run a digest cycle. Again, Angular does not update its bindings to HTML until a digest cycle runs. So at this point, we've turned that element into the expanded template that our eventthumbnail.html has, but none of the data has been bound. But, once we call scope.$digest, that kicks off a digest cycle and it'll go through and bind all of the data into the HTML, and now the HTML will have the values that we want. And now if we go and run our test, we can see that we've now got nine of nine tests, and all of them are passing. And this new test is actually checking that somewhere in our element we have the text Angular Expo, which is a pretty simple test. We could certainly do more complex stuff, but good enough to show the basics of testing directives. Now, let's talk for just a second about troubleshooting. One of the things that easy to do is to somehow get this wrong. For example, what if we misspelled that thumbnail? We said event thumbnail two, but of course, we only have the event thumbnail directive. If we run our test, and it's going to be failing. And all that we get is expected a blank string to contain Angular Expo. Again, the text property grabs all of the HTML that is there and looks at the inner text of each piece and appends it all together. But, what we're getting for that is a blank string. And that really doesn't tell me what's going wrong. So, one of the things that's really easy to do in order to diagnose what might be happening is to log out to the console the element, and this is a jQuery wrapped element, so we only need to grab the first one of those, because it's the jQuery wrap set. And we just want the first one, which is going to be R node, and then we can call the outer HTML property. And what this will do is actually write out to the console the entire HTML that gets compiled. So if we run out test again, we can look, and we see right here that the directive itself really didn't even get compiled. It's still just event-thumbnail two, with an event object. So, if we go in and change this to event thumbnail, and run our test again, then we can see that the HTML that gets printed out is actually the compiled HTML. So, it's taken that event thumbnail and replaced it with the contents of the event thumbnail HTML. So, now we know that the directive is getting compiled correctly. If we see just the original node, like when we have the two in there and nothing got changed, then we know that there's something wrong with just recognizing that this is a directive that we want. So, that's a good way to troubleshoot if you have a test for a directive that's failing and figure out why it's failing. And so, there's the basics of testing directives in Angular. As you can tell, there's quite a few steps that are involved. Understanding each of these steps is important so that whenever you have any problems you can diagnose and troubleshoot what the problem is.

End to End testing - Overview
In this section, we're going to cover end to end testing. End to end testing in Angular is a really, really cool piece of functionality that Angular provides. It's essentially integration testing, except it takes advantages of the internals of Angular, to make it a lot easier to integration test your application. If you've ever tested an application using something like Selenium, you'll know it can be very difficult and painful to test a web application that way because of the asynchronous nature of the web and constantly changing HTML. Angular's end to end testing mitigates a lot of those problems. Let's start by looking at a conceptual overview of Angular's end to end testing. First, you'll need to launch two things, Webdriver server, and your application server. Webdriver server is a special NPM module that you'll download and install. Your application server will either be your node server, your asp.net server or really whatever server that's serving up your application. Once those two pieces are running, you're ready to execute your end to end tests. Whether you're going to execute some pre-existing tests, or you're in the middle of writing some, the way that you execute tests is with Protractor. Once you launch Protractor, Protractor will read your tests and determine the steps that you want to execute in order to verify functionality in your application. Protractor then communicates with Webdriver server, Webdriver server then launches a browser and executes you application. At this point, the test is executed and the results are communicated back to Protractor, which reports to you whether the tests pass or failed. This process does have quite a few moving parts, but overall, it's fairly simple to get these parts installed and up and running.

Setting up Protractor
Setting up Protractor isn't particularly difficult, but it does involve a few steps. So, the first thing we need to do is install Protractor and Webdriver Manager itself. The first prerequisite that you must have installed is the Java Development Kit. And you can check and see if that's already installed in your box by typing in java-version. As long as you get something back, then you should be okay. If you don't, you're going to need to install the Java Development Kit. And installing that is a little bit beyond the scope of this course, because that could depend on your platform. But, the easiest thing to do is just Google JDK and the first result will be the download page for the Java Development Kit on oracle.com, and just follow their instructions to download it and get it installed correctly. Once you have that installed, the next thing to do is to install Protractor. Protractor is a node module so we'll use NPM and we will install Protractor, and we will install that globally with a -g. I'm not going to run this myself 'cause I've already got it installed and it can take a minute to download and install everything. But, it's a very simple process. And you may even notice, if you're on a Windows box, that you might get an error. You can possibly just ignore it 'cause some of the errors that it reports out aren't critical errors. Once you've installed Protractor, the next thing you need to do is update Webdriver Manager. Webdriver Manager is installled with Protractor. And to update that we use webdriver-manager and update. And once you run this command, that will update your Webdriver Manager. Updating it and once it's updated, we can start it up. And we'll need to have the Webdriver Manager started and running at all times. This is also known as the Selenium server. So, we just issue the start command to the Webdriver Manager, and we'll notice that it's now running, and this we will just leave running the entire time. The last piece we'll need to do in order to set up Protractor is to go back into our project, and we're going to need to create a config file for Protractor. So, I'm going to go to my test directory and I'm going to create a new file, and I'll name that protractor.conf.js. And this file is relatively simple. We will say exports.config equals an object. And if you're familiar with module systems, you'll recognize this syntax. If you're not, it's no big deal. Just follow along exactly. And this object needs a few properties. The first one is the address for the Selenium server and that's specified with a Selenium address. And we give it the string of the URL of the server. By default, the server's going to be running at localhost: 444/wd/hub. So unless you made any changes to your Webdriver Manager when you started it up, this is the URL that it's going to be available at. Next, we need to tell it where our tests are at, and that's with specs. And this is an array. We're only going to feed in one string property into this array, but of course, we could feed in multiple if we needed. And this is going to be our e2e, which is our folder, and inside of that, all the JavaScript files. And finally, we have to give it a capabilities property. And this is an object. And the only property that we need in here is the browser that we want to use. So, we're going to use Chrome. You give it a browser name, property, and inside of here specify Chrome. Be sure it's all lower case. We could use Fire Fox, or something else. For more information, you could always check out the Selenium documentation to see how to use other browsers, but we'll just use Chrome. Now, we could run Protractor at this point, but we get an error because there are no files that match this pattern here on the specs property, because there's no JS files inside of this e2e directory. So, let's go into our e2e directory, and let's create a new file. And we'll just name this scenarios.js. And we can just leave this blank. It doesn't actually have to have any code in it. Then, we'll go back out to the command line, and I've opened up a new console window because I've got to leave the Selenium server running in that other tab over here. So in this new terminal window, I'm going to run Protractor and then give it the path to the configuration file, which would be test/protractor.conf.js. And once I execute that, Protractor launches, runs. It found zero tests, so it didn't execute anything, but it did run, but now we can write tests and come back and run Protractor to run our tests.

Setting up Protractor with Webstorm
Setting up WebStorm to run Protractor is really nice because that way, you don't have to leave WebStorm in order to run you Protractor tests and go all the way back out to the console. So, we set it up kind of similar to how we set up Karma. We go to our configurations and edit configurations. Of course, you can find this on the Run menu if you don't have that toolbar visible. And I'm going to create a new configuration. And I'll select node. And now, I'm going to name this Protractor. And, there's a few things that are important. This node interpreter has to be set correctly. It by default should find where your node interpreter is, but you may need to double check that. Node parameters, we can leave blank. The working directory is going to usually be defaulted to the correct value, which is just the root of our application. The JavaScript file is going to be a little bit different. I'm going to need to actually find the cli.js inside of Protractor, which I installed globally. So on my computer, this is the path to my cli.js file. If your node is installed somewhere else, you may need to browse around to find it. But, inside of your node directory there's usually a bin directory that has your node modules, which will contain all of your globally installed node modules. And inside of that directory is a lib directory. And inside of that is the cli.js. Then, the final thing we need is application parameters, which is actually the path to the configuration file for Protractor. In which case, it's just test/protractor.conf.js. And once we have all the settings, we can click OK. And then, we've got Protractor selected and if we just click Run, WebStorm will run our Protractor tests for us. So, there we got Protractor set up in WebStorm.

Angular End to End testing - Part 1
In this section, we're going to write our first few end to end tests with Protractor. So, we'll start off in our scenarios file and put in a use strict, and then our describe. This will be our event registration app. And within this, we'll start by testing our events page, so let's put another describe. And events page will be that. And we'll start off by just navigating to the right page. So, before every test, we'll tell Protractor to go to the page we want to go to. And we do that in a before each function, and there's going to be a global brower variable, because we're inside Protractor, and we can call get, which will tell it to issue a get request, and we give it the URL that we want it to go to, which is local host and we are going to be at port 8000, which is where our app is running, and events is where we want it to point at. So before each test, Protractor will now browse to that URL. But, we do need to make sure that our server is actually running. So, this is one more moving part of running Protractor tests. Not only do we need Selenium Webdriver server running, we've also got to have our website running, and then we execute the tests inside of Protractor. So, there's kind of three pieces in that. So, I'll just go out to the command line and I still got Selenium running in my other tab. And inside of this tab, I'll run my server. And that's running on port 8000, and now if I execute this test, we've still got zero tests, zero assertions, but we're not getting any errors. So, next we'll actually write the test itself, which is going to be inside of an it function, and we'll say that it should have the correct title and first event. So, let's go ahead and look at our events page and see what I'm talking about. On our events page, we've got four events that are showing up. The first one has a title of Angular Boot Camp. So, this test will verify that that's the first event that's showing up. We've already told Protractor to go to the correct page, but let's look at the HTML that we're specifying inside of our Angular application, and that is at eventlist.html. You can see that what we got here is a repeater that is repeating over events in events. So, let's go back and we can actually find that repeater as a list. We'll say list equals element, which is a global that Protractor provides, and we'll say .all, which means that we're getting a list of elements. And we're going to find these elements by repeater. So, by.repeater is another thing that's provided to us by Protractor, and we can give it the event in events, which tells Protractor go and find a repeater that's on this page that's repeating over event in events. And now, we have that as a list. Now, let's first verify that we got the right number of events. So, our list should auto count it for us. So, we can expect that the list.count, which is a function, we'll expect that that equals four. So now if we run our test, it has come back and said that we've got one assertion and it's passing, and we've got no failures. So in addition to checking and making sure that we got four in our list, let's also make sure that the first one has the right title. So again, we want to find the correct element. In this case, we want to find the title of the first element, but let's check out the HTML and see what we're looking for. If we go into event list, we can see that we're just iterating over a list of event thumbnails. So, let's go into the event thumbnail HTML, and we can see that the event name is inside of this H2, and this is kind of binding to event.name. Well, we can take advantage of that. Going back into our file, we can find the element that has that binding. So, we can say for our title element equals element, which is again a function provided by Protractor, which helps us find elements. And we want to find this element by binding. Again, a little special function that Protractor provides that we can give it the name of a binding. So, in event thumbnail we're binding to event.name. So inside of a string, I'll say event.name and that will get the element that has a binding to event.name, which would ultimately be that H6 element. Once I've got the element, then I can set up an expectation, and expect that the title element, if we call get text on that, which will get the inner text, that that should equal the string Angular Boot Camp, which again, we can see that if we go back to the browser. You can see Angular Boot Camp with the first letter capitalized in all three words is what that text is. So, if we go and run our tests, we get two assertions now with zero failures. So, that's a good enough testing of our event list page. Let's also test our event details page. So, we'll put in a new describe. And we'll put in a before each instead of at. And in this case, we're not going to navigate to events. Instead, we will navigate to a specific event. And we'll go to event/1, and we can see what that looks like if we go to our browser, and browse to events/1. And here is our page and there's a lot of things on this that we can test. So, the first thing that we should do is make sure that it's sorting correctly and sorting by name. And that's our default sort order. And in that default sort order, our very first event is the Directives Master Class. So, let's say that it should sort by name. And we need to know what HTML we want to grab a hold of. And we can do that by looking at the event details HTML page. And if we scroll down, we can find the sessions inside this page. And we can see, here's our session's section, where we repeat over the sessionevent.sessions, and we can see that each session is detailed out by a collapsible directive. So, let's look at our collapsible directive and see what it's HTML is like. And there's the template for our collapsible directive and we can see that it's got an H4. And inside that H4, it binds to the title. So, let's go back to our scenarios, and we can do this a few different ways. Let's get a list again of all of the elements that are in the repeater. So our list equals element.all by repeater. I'm going back to our event details. We can see it's session in event.sessions. And that gives us our list of elements that are repeated over. And we can grab the very first one by calling first as a function, and then we can within this, find a element by calling the element function. And we can use that by binding. And this time, it's going to be a title. And let's capture that into a title element again. And then, let's expect that the title element get text is equal to Directives Master Class. And now if we run our tests, we can see that we got two tests with three assertions total and none of them are failing. So, one of the things that we see with this new test is that calling the element function on an element that we've already gotten right here where we call .first and then call .element after that, it actually searches just within that first element. And that's really nice. But, if we go up to our previous test and compare, we can see on line 13, right up here, that we don't do any filtering. We just call this element function which searches all elements on the entire page. And therefore on that page, there's actually four different bindings to event.name across the entire page. So because there's four, this function will actually just pull the first one by default. So, it's kind of the same thing as grabbing the list, grabbing the first element, and basically doing this. This is essentially the same thing, but it's a little bit more relying on the defaults inside of Protractor. Now, let's add one more test to our event details page. Let's test that we have the right number of sessions. So, if we go and we look at the browser, we can count and see that we've got three sessions inside of this event. And that will be what our test will verify. And so again, let's get our list of sessions. And let's expect that list.count is equal to three. And we'll run that test as well. And we can see that we've got three tests, four total assertions, all of them passing. So, there's some basic Protractor tests that show us how to find elements and check that the text inside of those elements is what we expect it to be. In the next section, we'll look at actually making some changes to the page interacting with it, and testing that the changes that we expect to happen, actually happened.

Angular End to End testing - Part 2
In this section, we're going to actually manipulate the page just like a user would, and test that the changes that we made produced the results that we were expecting. So, let's look at some of the things you might do. Let's go back to our page and if we were to select Introductory, then we can see that we're only seeing one session. And that session is Scopes for Fun and Profit. So, let's make a test that verifies that when we select the introductory filter, that we only see one session. So, there's the name of our test. And we will first grab a handle to the select element by creating the select el variable, and calling element. And this time if we look at the event details page, we can see that that filter is based on the NG model of query.level. So, one of the things that we can grab an element by is its model binding. So, we can say by.model and pass in query.level. And now we've got the select element that is bound to the query.level using the NG model directive. Now that we have it, we can say select el and we call the element function again, so that we can find the right option that we want and click it. And in this case, we're going to use the by css containing text, which is kind of a different selector. It takes in two parameters. The first parameter is sort of a css selector, so we're going to say it's an option tag. And the second one is the text that we're looking for, which in this case, is the word Introductory with a capital I. And once we have that element, we're going to click it. So, we just call .click. And now that we've changed that, our list should be different, so let's grab the list of elements, and we can again use element.all by.repeater, and this is session in event.sessions. And let's set up an expectation that list.count is equal to one. And let's run our test. And we have four total tests, five assertions, all passing. And of course, I should go in here and fix my spelling errors. Much better. Now that we've tested the filter, let's also test the sorter. So, let's just go back to the original unfiltered state, but instead of sorting by name, we're going to sort by votes. And here we can see why we used a different set of initial data, so that we actually have some votes specified. And now, this one sorts up to the top, whereas when we have name, Directives Master Classes had sort at the top. So, let's change the sorter to votes, and then check that this is the first one. So, our new test will be it should sort correctly when sort order is changed. So again, we'll grab the select element, but this time, it's not bound to the model of query level. Instead, it's bound to the model sort order, all lower case. So, we specify that. And now, we can find the right option using the same by css containing text, and that's an option. And the text that we want it to have is the word Votes, with a capital V, and we'll click that. And let's grab the first session, which would be element.all by repeater session in event.sessions and we want the first one of those. And that is going to be our first session. Now, we can grab the first session name, by saying first session and calling element on that, which looks for an element in this first session. And in order to find the first session, we'll go to our event details and look and see what we would have for a first session. Again, it's that collapsible and if we remember, the collapsible uses a binding to the title varible. So, let's go back and we can say by binding title. And since you want just the name, let's call get text on that. And now, we can set up an expectation, that first session name is equal to Scopes For Fun and Profit, making sure to get the casing right. And let's run those tests now. Make sure that our new test is passing. And of course that is passing. If we were to change what we're looking for and make it incorrect and run our test again, we get a failing test. We can see five tests, six assertions, one failure. So, let's fix that and rerun our tests, so we're back to a green state. And now, we'll write one more test. Let's test that if we were to up vote a particular session, that the vote count actually changes. So, go back to the default sort order and the default filter, and then we can see that our very first session has zero votes. And if we were to up vote it, it would go to one. So, our new test will be that it should increment the vote count when a session is up voted. Now this time, we need to figure out how to grab the voting buttons so that we can click it. So, let's go back into our event details HTML, and we can see that right here on line 43 is the up vote directive. So, let's look inside of the up vote directive and let's find out what element we want to grab to click and it's going to be on line two, this div with a class of voting button. And if we go back and look at the page, we can see that the very first div with a class of voting button is that one that we want to click. Of course, there's going to be multiple divs with class of voting button. There's one for the up chevron, and the, or the up vote, and one for the down vote, and there's one on each session. So between three sessions, we have six total buttons that are going to be div.voting button. But, that's okay, we just want the first one. So, let's grab element.all, and this time, we'll use the by deep css filter, and we can give it just a css selector, which will be div.voting button, which grabs a list of all six of those divs, and let's grab the first one, and then click it. And now, let's grab the first vote count element, and this is going to be element.all. And in this case, you want to grab the element that shows the vote. So if we go back to our up vote, we can see that this div here on line six has a binding to the account variable. So, we can just do there by binding selector, and we're going to find the one that's bound to the account variable. And again since we're dealing with the first one, we can just select that one, specifically. And of course, on our page there's three of those vote count bindings, one for each session, but we only care about the first one. And now, we can set up our expectation. We'll expect that the first vote count, and that if we call get text on that, that will give us just the text inside of that div. And we can make sure that it is equal to the string one. Now, let's run our tests. And we have six tests, seven total assertions, all of them are passing. So, there's some examples of how to interact with a page. Of course, there's a lot more than you can do. This course isn't an exhaustive coverage of Protractor and how it works. And remember, Protractor is just a wrapper over Webdriver. So, anything that works in Webdriver, will work with Protractor. But, Protractor adds some additional features and functionality. If you are interested in that, there are other courses that you can check out, or you can, of course, check out the official documentation. But, at least here, we've seen the basics of how to interact with a using Protractor and write end to end tests for our application.

Summary
In this module, we talked about testing with Angular. We started out by looking at Karma, our test runner. We looked at how to install and configure it. We also saw how to run it within WebStorm. We looked at some of the configuration options, and we saw what it looks like when we actually run Karma. Then we talked about unit testing. We learned about testing controllers, services, filters, and directives, and how to get Karma to test each of those pieces. And finally, we looked at end to end testing. We saw several examples of how to write end to end tests and talked about how to troubleshoot end to end tests. In Angular, testing is an integral piece of Angular. Writing very large JavaScript applications is very detailed and very complex. Because JavaScript is missing a lot of the features that other languages have, it can be very difficult to manage large applications. Therefore, testing is even more critical when it comes to JavaScript applications. I highly recommend that whenever you use Angular for you clientside code, that you test that code extensively with both unit tests and end to end tests.